# Adafruit MPU6050 Library for XIAO

## Overview

MPU6050 is a 6-axis motion tracking sensor with 3-axis gyroscope and 3-axis accelerometer. Includes onboard DMP for motion processing.

## Board Compatibility

All XIAO boards with I2C support:
- ESP32C3/C5/C6/S3: I2C on D4/D5
- nRF52840/MG24: I2C on D4/D5
- RP2040/RP2350: I2C on D4/D5
- SAMD21/RA4M1: I2C on D4/D5

## Pin Connection

```cpp
MPU6050       XIAO Board
-------       -----------
VCC    →      3.3V
GND    →      GND
SCL    →      D5 (I2C SCL)
SDA    →      D4 (I2C SDA)
XDA    →      Not connected (optional external I2C)
XCL    →      Not connected (optional external I2C)
AD0    →      GND (I2C address 0x68)
             or 3.3V (I2C address 0x69)
INT    →      D0 (optional interrupt pin)
```

## Basic Reading

```cpp
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>

Adafruit_MPU6050 mpu;

void setup() {
    Serial.begin(115200);

    if (!mpu.begin()) {
        Serial.println("MPU6050 not found!");
        while (1);
    }

    Serial.println("MPU6050 initialized");
}

void loop() {
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    Serial.println("Accelerometer:");
    Serial.printf("X: %.2f m/s^2\n", a.acceleration.x);
    Serial.printf("Y: %.2f m/s^2\n", a.acceleration.y);
    Serial.printf("Z: %.2f m/s^2\n", a.acceleration.z);

    Serial.println("Gyroscope:");
    Serial.printf("X: %.2f rad/s\n", g.gyro.x);
    Serial.printf("Y: %.2f rad/s\n", g.gyro.y);
    Serial.printf("Z: %.2f rad/s\n", g.gyro.z);

    Serial.println();
    delay(500);
}
```

## Sensor Configuration

```cpp
#include <Adafruit_MPU6050.h>

Adafruit_MPU6050 mpu;

void configureMPU() {
    // Set accelerometer range
    // MPU6050_RANGE_2_G
    // MPU6050_RANGE_4_G
    // MPU6050_RANGE_8_G
    // MPU6050_RANGE_16_G
    mpu.setAccelerometerRange(MPU6050_RANGE_2_G);

    // Set gyroscope range
    // MPU6050_RANGE_250_DEG
    // MPU6050_RANGE_500_DEG
    // MPU6050_RANGE_1000_DEG
    // MPU6050_RANGE_2000_DEG
    mpu.setGyroRange(MPU6050_RANGE_500_DEG);

    // Set filter bandwidth
    // MPU6050_BAND_260_HZ
    // MPU6050_BAND_184_HZ
    // MPU6050_BAND_94_HZ
    // MPU6050_BAND_44_HZ
    // MPU6050_BAND_21_HZ
    // MPU6050_BAND_10_HZ
    // MPU6050_BAND_5_HZ
    mpu.setFilterBandwidth(MPU6050_BAND_5_HZ);
}

void setup() {
    Serial.begin(115200);

    if (!mpu.begin()) {
        while (1);
    }

    configureMPU();
}

void loop() {
    delay(100);
}
```

## Orientation Detection

```cpp
#include <Adafruit_MPU6050.h>

Adafruit_MPU6050 mpu;

enum Orientation {
    PORTRAIT_UP,
    PORTRAIT_DOWN,
    LANDSCAPE_LEFT,
    LANDSCAPE_UP,
    FLAT
};

Orientation getOrientation(float ax, float ay, float az) {
    const float THRESHOLD = 5.0;

    if (abs(ax) < THRESHOLD && abs(ay) < THRESHOLD) {
        return FLAT;
    }

    if (abs(ax) > abs(ay)) {
        return (ax > 0) ? LANDSCAPE_LEFT : LANDSCAPE_UP;
    } else {
        return (ay > 0) ? PORTRAIT_UP : PORTRAIT_DOWN;
    }
}

void setup() {
    Serial.begin(115200);

    if (!mpu.begin()) {
        while (1);
    }
}

void loop() {
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    Orientation orientation = getOrientation(a.acceleration.x, a.acceleration.y, a.acceleration.z);

    switch (orientation) {
        case PORTRAIT_UP:
            Serial.println("Portrait Up");
            break;
        case PORTRAIT_DOWN:
            Serial.println("Portrait Down");
            break;
        case LANDSCAPE_LEFT:
            Serial.println("Landscape Left");
            break;
        case LANDSCAPE_UP:
            Serial.println("Landscape Right");
            break;
        case FLAT:
            Serial.println("Flat");
            break;
    }

    delay(500);
}
```

## Tap Detection

```cpp
#include <Adafruit_MPU6050.h>

Adafruit_MPU6050 mpu;

volatile bool tapDetected = false;

void IRAM_ATTR tapISR() {
    tapDetected = true;
}

void setup() {
    Serial.begin(115200);

    if (!mpu.begin()) {
        while (1);
    }

    // Enable tap detection
    mpu.writeRegister(MPU6050_INT_ENABLE, 0x08);  // Enable tap interrupt
    mpu.writeRegister(MPU6050_INT_PIN_CFG, 0x80);  // Interrupt is active low
    mpu.writeRegister(MPU6050_PWR_MGMT_1, 0);      // Wake up

    // Set up interrupt pin
    pinMode(D0, INPUT_PULLUP);
    attachInterrupt(digitalPinToInterrupt(D0), tapISR, FALLING);

    Serial.println("Tap detection enabled");
}

void loop() {
    if (tapDetected) {
        tapDetected = false;
        Serial.println("Tap detected!");
    }
    delay(10);
}
```

## Motion Detection

```cpp
#include <Adafruit_MPU6050.h>

Adafruit_MPU6050 mpu;

bool detectMotion(float threshold = 1.0) {
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    float magnitude = sqrt(
        a.acceleration.x * a.acceleration.x +
        a.acceleration.y * a.acceleration.y +
        a.acceleration.z * a.acceleration.z
    );

    return magnitude > threshold;
}

void setup() {
    Serial.begin(115200);

    if (!mpu.begin()) {
        while (1);
    }
}

void loop() {
    static bool wasMoving = false;
    bool isMoving = detectMotion();

    if (isMoving && !wasMoving) {
        Serial.println("Motion started!");
    } else if (!isMoving && wasMoving) {
        Serial.println("Motion stopped!");
    }

    wasMoving = isMoving;
    delay(100);
}
```

## Vibration Measurement

```cpp
#include <Adafruit_MPU6050.h>

Adafruit_MPU6050 mpu;

float measureVibration() {
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    // Calculate magnitude of acceleration
    float magnitude = sqrt(
        a.acceleration.x * a.acceleration.x +
        a.acceleration.y * a.acceleration.y +
        a.acceleration.z * a.acceleration.z
    );

    // Subtract gravity (approximately 9.81 m/s^2)
    float vibration = abs(magnitude - 9.81);

    return vibration;
}

void setup() {
    Serial.begin(115200);

    if (!mpu.begin()) {
        while (1);
    }

    // Configure for high sensitivity
    mpu.setAccelerometerRange(MPU6050_RANGE_2_G);
    mpu.setFilterBandwidth(MPU6050_BAND_260_HZ);
}

void loop() {
    float vibration = measureVibration();

    Serial.printf("Vibration: %.2f m/s^2\n", vibration);

    if (vibration > 2.0) {
        Serial.println("High vibration detected!");
    }

    delay(100);
}
```

## Data Fusion (Complementary Filter)

```cpp
#include <Adafruit_MPU6050.h>

Adafruit_MPU6050 mpu;

float pitch = 0.0;
float roll = 0.0;
unsigned long lastTime = 0;

void calculateOrientation() {
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    // Calculate dt
    unsigned long currentTime = millis();
    float dt = (currentTime - lastTime) / 1000.0;
    lastTime = currentTime;

    // Accelerometer angles
    float accel_pitch = atan2(a.acceleration.y, a.acceleration.z) * 180.0 / PI;
    float accel_roll = atan2(-a.acceleration.x, sqrt(a.acceleration.y * a.acceleration.y + a.acceleration.z * a.acceleration.z)) * 180.0 / PI;

    // Gyroscope integration
    float gyro_pitch = g.gyro.x * 180.0 / PI * dt;
    float gyro_roll = g.gyro.y * 180.0 / PI * dt;

    // Complementary filter (95% gyro, 5% accelerometer)
    const float alpha = 0.95;
    pitch = alpha * (pitch + gyro_pitch) + (1 - alpha) * accel_pitch;
    roll = alpha * (roll + gyro_roll) + (1 - alpha) * accel_roll;
}

void setup() {
    Serial.begin(115200);

    if (!mpu.begin()) {
        while (1);
    }

    mpu.setGyroRange(MPU6050_RANGE_250_DEG);
    mpu.setFilterBandwidth(MPU6050_BAND_5_HZ);

    lastTime = millis();
}

void loop() {
    calculateOrientation();

    Serial.printf("Pitch: %.1f°, Roll: %.1f°\n", pitch, roll);

    delay(50);
}
```

## Data Logging

```cpp
#include <Adafruit_MPU6050.h>
#include <LittleFS.h>

Adafruit_MPU6050 mpu;

void logSensorData() {
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    File file = LittleFS.open("/imu.csv", "a");
    if (file) {
        file.printf("%lu,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f\n",
                    millis(),
                    a.acceleration.x, a.acceleration.y, a.acceleration.z,
                    g.gyro.x, g.gyro.y, g.gyro.z);
        file.close();
    }
}

void setup() {
    Serial.begin(115200);
    LittleFS.begin();

    if (!mpu.begin()) {
        while (1);
    }

    // Create CSV header
    File file = LittleFS.open("/imu.csv", "w");
    file.println("timestamp,ax,ay,az,gx,gy,gz");
    file.close();
}

void loop() {
    logSensorData();
    delay(100);
}
```

## OLED Display

```cpp
#include <Adafruit_MPU6050.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

Adafruit_MPU6050 mpu;
Adafruit_SSD1306 display(128, 64, &Wire, -1);

void setup() {
    Serial.begin(115200);

    if (!mpu.begin() || !display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
        while (1);
    }

    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
}

void loop() {
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    display.clearDisplay();
    display.setCursor(0, 0);

    display.println("MPU6050");
    display.println();

    display.printf("X: %.1f\n", a.acceleration.x);
    display.printf("Y: %.1f\n", a.acceleration.y);
    display.printf("Z: %.1f\n", a.acceleration.z);

    display.display();
    delay(200);
}
```

## Best Practices

```cpp
#include <Adafruit_MPU6050.h>

void setup() {
    Serial.begin(115200);

    // Best practice 1: Check initialization
    if (!mpu.begin()) {
        Serial.println("Failed to find MPU6050 chip");
        while (1) delay(10);
    }

    // Best practice 2: Configure for application
    mpu.setAccelerometerRange(MPU6050_RANGE_2_G);  // Use lowest range for precision
    mpu.setGyroRange(MPU6050_RANGE_250_DEG);       // Use lowest range for precision
    mpu.setFilterBandwidth(MPU6050_BAND_5_HZ);     // Lower bandwidth for noise reduction
}

// Best practice 3: Calibrate sensor
void calibrate() {
    // Run calibration routine
    // Record offset values
    float offset_ax = 0, offset_ay = 0, offset_az = 0;
    int samples = 100;

    for (int i = 0; i < samples; i++) {
        sensors_event_t a, g, temp;
        mpu.getEvent(&a, &g, &temp);
        offset_ax += a.acceleration.x;
        offset_ay += a.acceleration.y;
        offset_az += a.acceleration.z - 9.81;  // Subtract gravity
        delay(10);
    }

    offset_ax /= samples;
    offset_ay /= samples;
    offset_az /= samples;

    // Apply offsets in readings
}

// Best practice 4: Use appropriate sampling rate
void loop() {
    // Don't sample faster than needed
    // 100Hz is sufficient for most applications
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);
    delay(10);
}

// Best practice 5: Check for valid data
bool isValidReading(float value, float min, float max) {
    return !isnan(value) && value >= min && value <= max;
}
```

## References

- [Adafruit MPU6050 Library](https://github.com/adafruit/Adafruit_MPU6050)
- [MPU6050 Register Map](https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Register-Map1.pdf)
