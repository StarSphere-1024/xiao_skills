# RS485 Expansion Board for XIAO - Arduino

## Overview

Arduino implementation for the XIAO RS485 Expansion Board. Industrial RS485 communication for long-distance networking in noisy environments.

## Hardware Reference

For hardware specifications, pin connections, and compatibility, see `/xiao/references/expansion_boards/rs485.md`.

## Pin Connections

| Function | XIAO Pin | Notes |
|----------|----------|-------|
| RX | D4 (GPIO6 on ESP32) | Receive data |
| TX | D5 (GPIO7 on ESP32) | Transmit data |
| Enable | D2 | TX/RX control (HIGH=TX) |

**Board Features:**
- 5V OUT/IN switch for power management
- 120Ω termination switch
- Half-duplex communication

## Required Libraries

| Library | Purpose |
|---------|---------|
| **ArduinoRS485** | RS485 standard library |
| **HardwareSerial** | Built-in UART |

## Basic RS485 Communication

### Master (Transmitter)

```cpp
#include <ArduinoRS485.h>

#define RS485_TX_ENABLE D2

void setup() {
  Serial.begin(115200);
  RS485.begin(9600);
  RS485.setTxEnablePin(RS485_TX_ENABLE);
  RS485.beginTransmission();
}

void loop() {
  RS485.beginTransmission();
  RS485.print("Hello Slave!");
  RS485.endTransmission();
  delay(1000);
}
```

### Slave (Receiver)

```cpp
#include <ArduinoRS485.h>

#define RS485_TX_ENABLE D2

void setup() {
  Serial.begin(115200);
  RS485.begin(9600);
  RS485.setTxEnablePin(RS485_TX_ENABLE);
  // Receiver keeps enable LOW (receiving)
  digitalWrite(RS485_TX_ENABLE, LOW);
}

void loop() {
  if (RS485.available()) {
    char c = RS485.read();
    Serial.write(c);  // Echo to USB
  }
}
```

## Modbus RTU Master

```cpp
#include <ArduinoRS485.h>
#include <ModbusMaster.h>

#define RS485_TX_ENABLE D2

ModbusMaster node;
uint8_t result;

void preTransmission() {
  digitalWrite(RS485_TX_ENABLE, HIGH);
}

void postTransmission() {
  digitalWrite(RS485_TX_ENABLE, LOW);
}

void setup() {
  Serial.begin(115200);
  RS485.begin(9600);
  RS485.setTxEnablePin(RS485_TX_ENABLE);

  node.begin(1, RS485);  // Slave ID 1
  node.preTransmission(preTransmission);
  node.postTransmission(postTransmission);
}

void loop() {
  // Read holding register
  result = node.readHoldingRegisters(0, 1);

  if (result == node.ku8MBSuccess) {
    Serial.print("Value: ");
    Serial.println(node.getResponseBuffer(0));
  } else {
    Serial.print("Error: ");
    Serial.println(result);
  }
  delay(1000);
}
```

## Multi-Drop Network

### Master Node

```cpp
#include <ArduinoRS485.h>

#define RS485_TX_ENABLE D2

void setup() {
  Serial.begin(115200);
  RS485.begin(9600);
  RS485.setTxEnablePin(RS485_TX_ENABLE);
}

void sendTo(byte slaveId, const char* message) {
  RS485.beginTransmission();

  // Send header with slave ID
  RS485.write(slaveId);
  RS485.write(':');

  // Send message
  RS485.print(message);
  RS485.write('\n');

  RS485.endTransmission();

  Serial.print("Sent to ");
  Serial.print(slaveId);
  Serial.print(": ");
  Serial.println(message);
}

void loop() {
  sendTo(1, "Status?");
  delay(500);

  sendTo(2, "Status?");
  delay(500);

  sendTo(3, "Status?");
  delay(1000);
}
```

### Slave Node (ID=1)

```cpp
#include <ArduinoRS485.h>

#define RS485_TX_ENABLE D2
#define MY_ID 1

void setup() {
  Serial.begin(115200);
  RS485.begin(9600);
  RS485.setTxEnablePin(RS485_TX_ENABLE);
  digitalWrite(RS485_TX_ENABLE, LOW);  // Receive mode
}

void respond(const char* response) {
  RS485.beginTransmission();
  RS485.write(MY_ID);
  RS485.write(':');
  RS485.print(response);
  RS485.write('\n');
  RS485.endTransmission();
}

void loop() {
  if (RS485.available()) {
    byte senderId = RS485.read();
    if (senderId == MY_ID) {
      // Check for colon separator
      if (RS485.read() == ':') {
        String command = RS485.readStringUntil('\n');

        if (command == "Status?") {
          respond("OK");
          Serial.println("Responded: OK");
        } else if (command == "Ping") {
          respond("Pong");
          Serial.println("Responded: Pong");
        }
      }
    }
  }
}
```

## 120Ω Termination

Enable termination for networks longer than 10 meters or with more than 2 nodes:

```
Switch ON: 120Ω termination enabled (default OFF)
```

## Power Management

The 5V OUT/IN switch controls power to RS485 transceiver:

- **OUT:** Provide 5V to external devices from XIAO
- **IN:** Accept 5V from external source (protects XIAO)

## Troubleshooting

### No Communication

**Symptom:** Messages not received

**Possible Causes:**
1. Wiring issue (A/B swapped)
2. No termination resistor
3. Wrong baud rate

**Solution:**
- Verify A to A, B to B connections
- Enable 120Ω termination for longer networks
- Match baud rate on all devices

### Garbled Data

**Symptom:** Received data corrupted

**Possible Causes:**
1. Baud rate mismatch
2. Electrical noise
3. Ground loop issues

**Solution:**
- Use shielded twisted pair cable
- Verify common ground
- Add line termination if missing

### Bus Contention

**Symptom:** Multiple devices talking at once

**Possible Causes:**
1. Polling not implemented
2. Enable timing issue

**Solution:**
- Implement master-slave polling
- Add delay between TX/RX switching

## Wiring Guidelines

For reliable RS485 communication:

1. **Use twisted pair:** STP (shielded twisted pair) cable recommended
2. **Terminate:** Enable 120Ω at both ends of bus
3. **Bias:** May need bias resistors for idle bus state
4. **Ground:** Common ground between all nodes
5. **Length:** Up to 1200 meters at lower baud rates
