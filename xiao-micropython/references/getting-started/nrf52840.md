# MicroPython on XIAO nRF52840

## Overview

The SeeedStudio XIAO nRF52840 features the Nordic nRF52840 chip with BLE 5.0, NFC, and USB support.

## Board Specifications

| Feature | Value |
|---------|-------|
| MCU | nRF52840 (ARM Cortex-M4F, 64MHz) |
| Flash | 1 MB |
| RAM | 256 KB |
| BLE | Bluetooth 5.0 |
| NFC | NFC |
| USB | Native USB |
| ADC | 12-bit ADC (see nRF52840 PS for details) |

## Pin Mapping for MicroPython

Seeed XIAO pin map (this repo: `Ref/PinOut/XIAO_Pinout_Reference.csv`).
Use `P0.xx` / `P1.xx` naming in MicroPython to avoid ambiguity.

| XIAO Pin | nRF Pin | MicroPython | Notes |
|----------|---------|------------|-------|
| D0 | P0.02 | Pin("P0.02") | ADC |
| D1 | P0.03 | Pin("P0.03") | ADC |
| D2 | P0.28 | Pin("P0.28") | ADC |
| D3 | P0.29 | Pin("P0.29") | ADC |
| D4 | P0.04 | Pin("P0.04") | I2C SDA (XIAO standard) |
| D5 | P0.05 | Pin("P0.05") | I2C SCL (XIAO standard) |
| D6 | P1.11 | Pin("P1.11") | UART TX (XIAO standard) |
| D7 | P1.12 | Pin("P1.12") | UART RX (XIAO standard) |
| D8 | P1.13 | Pin("P1.13") | SPI SCK (XIAO standard) |
| D9 | P1.14 | Pin("P1.14") | SPI MISO (XIAO standard) |
| D10 | P1.15 | Pin("P1.15") | SPI MOSI (XIAO standard) |

Other key pins (Seeed Wiki, XIAO nRF52840 Series):

- **ADC_BAT** (battery voltage sense): P0.14
- **NFC1/NFC2**: P0.09 / P0.10
- **USER_LED_R/B/G** (on-board RGB LED): P0.26 / P0.06 / P0.30

## Flashing MicroPython Firmware

### 1. Download Firmware

Upstream MicroPython provides firmware downloads on the official download page.
For nRF boards, filter by port `nrf`.

### 2. Enter Boot Mode

If your board's bootloader exposes a USB Mass Storage device, enter bootloader
mode (commonly via a double-reset) and the board will appear as a removable drive.

### 4. Copy UF2 File

1. Download `.uf2` firmware file
2. Copy/drag it to the bootloader drive (drive name varies by bootloader)
3. Drive disconnects and reconnect
4. Ready to use!

### 5. Connect with Thonny

1. Open Thonny IDE
2. Tools > Options > Interpreter
3. Select a suitable MicroPython interpreter (board/port-specific)
4. Select port and click OK

## First Script

```python
from machine import Pin
import time

# On-board RGB LED (XIAO nRF52840 series, Seeed Wiki).
led = Pin("P0.26", Pin.OUT)

while True:
    led.value(0)
    time.sleep(1)

    led.value(1)
    time.sleep(1)
```

## GPIO Control

```python
from machine import Pin
import time

# Input with pull-up (D6 = P1.11)
button = Pin("P1.11", Pin.IN, Pin.PULL_UP)

# Output (D13 = P0.30)
led = Pin("P0.30", Pin.OUT)

while True:
    if button.value() == 0:
        led.value(0)  # LED on
    else:
        led.value(1)  # LED off
    time.sleep(0.1)
```

## I2C Configuration

```python
from machine import Pin, I2C
import time

# I2C on D4 (SDA) and D5 (SCL)
i2c = I2C(0, sda=Pin("P0.04"), scl=Pin("P0.05"), freq=100000)

# Scan for devices
devices = i2c.scan()
print(f"I2C devices: {[hex(d) for d in devices]}")

# Read/write
i2c.writeto(0x76, b'\x00')  # Write
data = i2c.readfrom(0x76, 8)  # Read
print(f"Data: {data}")
```

## SPI Configuration

```python
from machine import Pin, SPI

# SPI configuration
spi = SPI(0, sck=Pin("P1.13"), mosi=Pin("P1.15"), miso=Pin("P1.14"), baudrate=1000000)

# Chip select (example: D3 = P0.29)
cs = Pin("P0.29", Pin.OUT)

# Transfer
cs.value(0)
data = spi.read(8)
cs.value(1)

print(f"SPI data: {data}")
```

## UART Configuration

```python
from machine import UART, Pin

# UART on D6 (TX) and D7 (RX)
uart = UART(0, tx=Pin("P1.11"), rx=Pin("P1.12"), baudrate=115200)

uart.write('Hello XIAO nRF52840!\n')

while True:
    if uart.any():
        data = uart.read()
        print(f"Received: {data}")
```

## PWM Output

```python
from machine import Pin, PWM
import time

# PWM on D13 (P0.30)
pwm = PWM(Pin("P0.30"))
pwm.freq(1000)
pwm.duty(512)  # 50%

# Fade
for duty in range(0, 1024, 16):
    pwm.duty(duty)
    time.sleep(0.01)
```

## ADC Reading

```python
from machine import ADC, Pin
import time

# ADC on A0 (D0)
adc = ADC(Pin("P0.02"))

while True:
    value = adc.read_u16()  # 0-65535
    # Voltage conversion is board- and firmware-dependent.
    print(f"ADC raw: {value}")
    time.sleep(0.5)
```

## BLE Advertising

```python
import bluetooth
import time

ble = bluetooth.BLE()
ble.active(True)

# Minimal advertising payload (flags only)
ble.gap_advertise(100, b"\x02\x01\x06")

print("Advertising...")
time.sleep(10)
ble.gap_advertise(None)  # Stop
```

## BLE Peripheral (Simple Service)

```python
import bluetooth
import struct

ble = bluetooth.BLE()
ble.active(True)

# Define service
DEVICE_NAME = "XIAO-nRF"

# UART service
_IRQ_CENTRAL_CONNECT = 1
_IRQ_CENTRAL_DISCONNECT = 2

def ble_irq(event, data):
    if event == _IRQ_CENTRAL_CONNECT:
        print("Connected")
    elif event == _IRQ_CENTRAL_DISCONNECT:
        print("Disconnected")
        ble.gap_advertise(100)

ble.irq(ble_irq)

UART_UUID = bluetooth.UUID("6E400001-B5A3-F393-E0A9-E50E24DCCA9E")
UART_RX = bluetooth.UUID("6E400002-B5A3-F393-E0A9-E50E24DCCA9E")
UART_TX = bluetooth.UUID("6E400003-B5A3-F393-E0A9-E50E24DCCA9E")

uart_service = (
    UART_UUID,
    (
        (UART_TX, bluetooth.FLAG_READ | bluetooth.FLAG_NOTIFY),
        (UART_RX, bluetooth.FLAG_WRITE),
    ),
)

services = (uart_service,)
((handle_tx, handle_rx),) = ble.gatts_register_services(services)

# Start advertising
ble.gap_advertise(100, b"\x02\x01\x06")

print("BLE UART service running")
```

## BLE Central (Scan)

```python
import bluetooth
import time

ble = bluetooth.BLE()
ble.active(True)

def bt_irq(event, data):
    if event == 5:  # Scan result
        addr_type, addr, adv_type, rssi, adv_data = data
        print(f"Found: {addr.hex()} RSSI: {rssi}")

ble.irq(bt_irq)

# Scan for 10 seconds
ble.gap_scan(2000, 10000)

time.sleep(11)
ble.gap_scan(None)
```

## NFC (Basic)

NFC support is hardware- and firmware-dependent. Upstream MicroPython does not
define a generic `machine.NFC()` API. If you need NFC, consult your firmware's
documentation/source or vendor-provided builds.

## Deep Sleep

```python
import machine
import time

print("Going to deep sleep...")

# Light sleep
# Note: on the upstream MicroPython `nrf` port (v1.27.0), the optional time_ms
# argument is not used by the port implementation.
machine.lightsleep()

print("Woke from light sleep")

# Deep sleep
# Note: on the upstream MicroPython `nrf` port (v1.27.0), deepsleep() is
# implemented as a system reset.
machine.deepsleep()
```

## Low Power Mode

```python
import machine
import time

# Disable unused peripherals
# Don't initialize UART, I2C, SPI if not needed

# Light sleep for power saving
while True:
    print("Active...")
    time.sleep(1)

    # Enter light sleep
    machine.lightsleep()

    print("Woke up")
```

## Watchdog Timer

```python
import machine
import time

# Watchdog (if available)
try:
    wdt = machine.WDT(timeout=5000)

    while True:
        print("Watchdog fed")
        wdt.feed()
        time.sleep(1)
except:
    print("WDT not available")
```

## Battery Measurement

```python
from machine import ADC, Pin
import time

# Battery sense on XIAO nRF52840 Sense (Seeed Wiki: ADC_BAT = P0.14)
try:
    adc = ADC(Pin("P0.14"))

    while True:
        value = adc.read_u16()
        print("ADC_BAT raw:", value)
        time.sleep(5)
except:
    print("Battery measurement not configured")
```

## Flash Storage

```python
import uos

# List files
print("Files:", uos.listdir())

# Write file
with open('data.txt', 'w') as f:
    f.write('Hello XIAO nRF52840')

# Read file
with open('data.txt', 'r') as f:
    data = f.read()
    print(f"Read: {data}")
```

## Key Differences from ESP32

| Feature | ESP32 | nRF52840 |
|---------|-------|----------|
| Wireless | WiFi + BLE | BLE only |
| USB | Device only | Device only |
| Bootloader | Serial | UF2 drag-and-drop |
| Flashing | esptool | Copy UF2 file |
| Deep Sleep | Full support | Port-specific (upstream `nrf` port v1.27.0 implements `deepsleep()` as reset) |
| Power | Varies by design | Varies by design |

## Troubleshooting

### Can't see UF2 drive

1. Double-click RESET button quickly
2. Look for a removable bootloader drive (drive name varies)
3. Try different USB cable
4. Check LED indicates bootloader mode

### Thonny can't connect

1. Check device manager for COM port
2. Verify MicroPython installed
3. Try reinstalling firmware
4. Check baud rate (115200)

### BLE not working

1. Check BLE is active: `ble.active(True)`
2. Verify advertising parameters
3. Check for other BLE devices interference
4. Restart if needed

### Deep sleep not working

1. `machine.deepsleep()` / `machine.lightsleep()` behavior depends on the MicroPython port
2. On upstream MicroPython `nrf` port (v1.27.0), `deepsleep()` is a reset and `lightsleep()` has no timeout

### High power consumption

1. Ensure BLE advertising interval is long
2. Disable unused peripherals
3. Consult the nRF52840 PS and board schematic for low-power design
4. Check for floating GPIO pins

## Best Practices

1. **Use UF2 bootloader** - easy firmware updates
2. **Optimize BLE advertising** - longer intervals save power
3. **Treat `lightsleep()` / `deepsleep()` as port-specific** - verify behavior on your firmware build
4. **Use flash storage** for data persistence
5. **Optimize BLE connection parameters**

## Complete Example: BLE Sensor

```python
import bluetooth
import struct
import time
from machine import ADC, Pin

# BLE setup
ble = bluetooth.BLE()
ble.active(True)

# Sensor (ADC on A0 = P0.02)
adc = ADC(Pin("P0.02"))

# Register a simple custom service that reports raw ADC readings.
ADC_SERVICE_UUID = bluetooth.UUID("12345678-1234-5678-1234-56789abcdef0")
ADC_CHAR_UUID = bluetooth.UUID("12345678-1234-5678-1234-56789abcdef1")

adc_service = (ADC_SERVICE_UUID, (
    (ADC_CHAR_UUID, bluetooth.FLAG_READ | bluetooth.FLAG_NOTIFY),
),)

((adc_handle,),) = ble.gatts_register_services((adc_service,))

def read_adc_u16():
    return adc.read_u16()

# Advertising
def advertise():
    name = b'XIAO-Sensor'
    adv_data = struct.pack('BBB', 2, 0x01, 0x06)  # Flags
    adv_data += struct.pack('BB', len(name) + 1, 0x09)  # Name
    adv_data += name

    ble.gap_advertise(100, adv_data)

# IRQ handler
def ble_irq(event, data):
    global conn_handle
    if event == 1:  # Connected
        conn_handle, _, _ = data
        print("Connected")
    elif event == 2:  # Disconnected
        conn_handle = None
        print("Disconnected")
        advertise()

ble.irq(ble_irq)

# Start
advertise()

conn_handle = None

# Main loop
last_update = 0

while True:
    now = time.ticks_ms()

    # Update every 5 seconds
    if time.ticks_diff(now, last_update) > 5000:
        value = read_adc_u16()
        ble.gatts_write(adc_handle, struct.pack('<H', value))
        if conn_handle is not None:
            ble.gatts_notify(conn_handle, adc_handle)
        print(f"ADC raw: {value}")
        last_update = now

    time.sleep(0.1)
```

## Migration from Arduino

```python
# Arduino nRF52840 code needs changes for MicroPython:

# 1. No setup/loop structure - just top-level code
# 2. Pin naming: prefer Pin("P0.xx"/"P1.xx") on nRF to avoid ambiguity
# 3. Different BLE API - use bluetooth module
# 4. Different sleep functions
# 5. Interrupts: use Pin.irq() not attachInterrupt()

# Example Arduino:
# void setup() {
#     pinMode(6, OUTPUT);
# }
# void loop() {
#     digitalWrite(6, HIGH);
#     delay(1000);
# }

# MicroPython equivalent:
from machine import Pin
import time

led = Pin("P0.30", Pin.OUT)

while True:
    led.value(1)
    time.sleep(1)
    led.value(0)
    time.sleep(1)

```

## References

- Seeed XIAO pin reference (this repo): `Ref/PinOut/XIAO_Pinout_Reference.csv`
- Seeed Wiki (XIAO nRF52840 series getting started, pin functions incl. ADC_BAT and USER_LED_*): https://wiki.seeedstudio.com/XIAO_BLE/
- MicroPython `machine` module documentation: https://docs.micropython.org/en/latest/library/machine.html
- Upstream MicroPython source (v1.27.0) `nrf` port `machine` implementation (lightsleep/deepsleep): https://github.com/micropython/micropython/blob/v1.27.0/ports/nrf/modules/machine/modmachine.c
- MicroPython downloads page (filter by port `nrf`): https://micropython.org/download/
```
