# MicroPython on XIAO nRF52840

## Overview

The SeeedStudio XIAO nRF52840 features the Nordic nRF52840 chip with BLE 5.0, NFC, and USB support.

## Board Specifications

| Feature | Value |
|---------|-------|
| MCU | nRF52840 (ARM Cortex-M4F, 64MHz) |
| Flash | 1 MB |
| RAM | 256 KB |
| BLE | Bluetooth 5.0 |
| NFC | NFC-A/B |
| USB | Native USB |
| GPIO | 21 pins |
| ADC | 12-bit, 6 channels |
| PWM | 12 channels |

## Pin Mapping for MicroPython

Seeed Ref pin map (use `P0.xx` / `P1.xx` naming to avoid ambiguity):

| XIAO Pin | nRF Pin | MicroPython | Notes |
|----------|---------|------------|-------|
| D0 | P0.02 | Pin("P0.02") | ADC |
| D1 | P0.03 | Pin("P0.03") | ADC |
| D2 | P0.28 | Pin("P0.28") | ADC |
| D3 | P0.29 | Pin("P0.29") | ADC |
| D4 | P0.04 | Pin("P0.04") | I2C SDA (XIAO standard) |
| D5 | P0.05 | Pin("P0.05") | I2C SCL (XIAO standard) |
| D6 | P1.11 | Pin("P1.11") | UART TX (XIAO standard) |
| D7 | P1.12 | Pin("P1.12") | UART RX (XIAO standard) |
| D8 | P1.13 | Pin("P1.13") | SPI SCK (XIAO standard) |
| D9 | P1.14 | Pin("P1.14") | SPI MISO (XIAO standard) |
| D10 | P1.15 | Pin("P1.15") | SPI MOSI (XIAO standard) |

Other key pins (from Seeed Ref pin map):

- **RESET**: P0.18
- **ADC_BAT**: P0.14
- **NFC1/NFC2**: P0.09 / P0.10
- **USER_LED_R/B/G**: P0.26 / P0.06 / P0.30

## Flashing MicroPython Firmware

### 1. Download Firmware

Download nRF52840 MicroPython firmware from:
https://micropython.org/download/nrf52840/

### 2. Install uf2tool or use drag-and-drop

nRF52840 uses UF2 bootloader - no esptool needed!

### 3. Enter Boot Mode

1. Double-click RESET button to enter bootloader
2. XIAO appears as "FDRNRF52840" drive

### 4. Copy UF2 File

1. Download `.uf2` firmware file
2. Copy/drag to "FDRNRF52840" drive
3. Drive disconnects and reconnect
4. Ready to use!

### 5. Connect with Thonny

1. Open Thonny IDE
2. Tools > Options > Interpreter
3. Select "MicroPython (nRF52840)"
4. Select port and click OK

## First Script

```python
from machine import Pin
import time

# User LED (RGB) - choose one channel to blink
led = Pin("P0.26", Pin.OUT)  # USER_LED_R

while True:
    led.value(0)  # LED is active low
    print("LED ON")
    time.sleep(1)

    led.value(1)
    print("LED OFF")
    time.sleep(1)
```

## GPIO Control

```python
from machine import Pin
import time

# Input with pull-up
button = Pin(6, Pin.IN, Pin.PULL_UP)

# Output
led = Pin(13, Pin.OUT)

while True:
    if button.value() == 0:
        led.value(0)  # LED on
    else:
        led.value(1)  # LED off
    time.sleep(0.1)
```

## I2C Configuration

```python
from machine import Pin, I2C
import time

# I2C on D4 (SDA) and D5 (SCL)
i2c = I2C(0, sda=Pin("P0.04"), scl=Pin("P0.05"), freq=100000)

# Scan for devices
devices = i2c.scan()
print(f"I2C devices: {[hex(d) for d in devices]}")

# Read/write
i2c.writeto(0x76, b'\x00')  # Write
data = i2c.readfrom(0x76, 8)  # Read
print(f"Data: {data}")
```

## SPI Configuration

```python
from machine import Pin, SPI

# SPI configuration
spi = SPI(0, sck=Pin("P1.13"), mosi=Pin("P1.15"), miso=Pin("P1.14"), baudrate=1000000)

# Chip select
cs = Pin(4, Pin.OUT)

# Transfer
cs.value(0)
data = spi.read(8)
cs.value(1)

print(f"SPI data: {data}")
```

## UART Configuration

```python
from machine import UART, Pin

# UART on D6 (TX) and D7 (RX)
uart = UART(0, tx=Pin("P1.11"), rx=Pin("P1.12"), baudrate=115200)

uart.write('Hello XIAO nRF52840!\n')

while True:
    if uart.any():
        data = uart.read()
        print(f"Received: {data}")
```

## PWM Output

```python
from machine import Pin, PWM
import time

# PWM on D6
pwm = PWM(Pin(6))
pwm.freq(1000)
pwm.duty(512)  # 50%

# Fade
for duty in range(0, 1024, 16):
    pwm.duty(duty)
    time.sleep(0.01)
```

## ADC Reading

```python
from machine import ADC, Pin
import time

# ADC on A0 (D0)
adc = ADC(Pin("P0.02"))

while True:
    value = adc.read_u16()  # 0-65535
    voltage = value * 3.3 / 65535
    print(f"ADC: {value}, Voltage: {voltage:.2f}V")
    time.sleep(0.5)
```

## BLE Advertising

```python
import bluetooth
import time

ble = bluetooth.BLE()
ble.active(True)

# Simple advertising
ble.gap_advertise(100, b'\x02\x01\x06\x03\x03AA-AA-AA')

print("Advertising...")
time.sleep(10)
ble.gap_advertise(None)  # Stop
```

## BLE Peripheral (Simple Service)

```python
import bluetooth
import struct

ble = bluetooth.BLE()
ble.active(True)

# Define service
DEVICE_NAME = "XIAO-nRF"

# UART service
_IRQ_CENTRAL_CONNECT = 1
_IRQ_CENTRAL_DISCONNECT = 2

def ble_irq(event, data):
    if event == _IRQ_CENTRAL_CONNECT:
        print("Connected")
    elif event == _IRQ_CENTRAL_DISCONNECT:
        print("Disconnected")
        ble.gap_advertise(100)

ble.irq(ble_irq)

# Register UART service
uart_service = (
    bluetooth.UUID(0x6E400001-B5A3-F393-E0A9-E50E24DCCA9E),
    [
        (bluetooth.UUID(0x6E400002-B5A3-F393-E0A9-E50E24DCCA9E), bluetooth.FLAG_READ | bluetooth.FLAG_NOTIFY),
        (bluetooth.UUID(0x6E400003-B5A3-F393-E0A9-E50E24DCCA9E), bluetooth.FLAG_WRITE),
    ],
)

services = (uart_service,)
((handle_tx, handle_rx),) = ble.gatts_register_services(services)

# Start advertising
ble.gap_advertise(100, b'\x02\x01\x06\x03\x03AA-AA-AA')

print("BLE UART service running")
```

## BLE Central (Scan)

```python
import bluetooth
import time

ble = bluetooth.BLE()
ble.active(True)

def bt_irq(event, data):
    if event == 5:  # Scan result
        addr_type, addr, adv_type, rssi, adv_data = data
        print(f"Found: {addr.hex()} RSSI: {rssi}")

ble.irq(bt_irq)

# Scan for 10 seconds
ble.gap_scan(2000, 10000)

time.sleep(11)
ble.gap_scan(None)
```

## NFC (Basic)

```python
import machine
import time

# NFC is limited in MicroPython nRF port
# May require custom firmware or external library

# Check NFC availability
try:
    nfc = machine.NFC()
    print("NFC available")
except:
    print("NFC not available in this firmware")
```

## Deep Sleep

```python
import machine
import time

print("Going to deep sleep...")

# Light sleep
machine.lightsleep(5000)

print("Woke from light sleep")

# Deep sleep (if supported)
try:
    machine.deepsleep(10000)
except:
    print("Deep sleep not fully supported")
```

## Low Power Mode

```python
import machine
import time

# Disable unused peripherals
# Don't initialize UART, I2C, SPI if not needed

# Light sleep for power saving
while True:
    print("Active...")
    time.sleep(1)

    # Enter light sleep
    machine.lightsleep(5000)

    print("Woke up")
```

## Watchdog Timer

```python
import machine
import time

# Watchdog (if available)
try:
    wdt = machine.WDT(timeout=5000)

    while True:
        print("Watchdog fed")
        wdt.feed()
        time.sleep(1)
except:
    print("WDT not available")
```

## Battery Measurement

```python
from machine import ADC
import time

# Battery on VBUS pin (if available)
try:
    adc = ADC(Pin(3))  # A0

    while True:
        value = adc.read_u16()
        # Adjust for your voltage divider
        voltage = value * 3.6 / 65535
        percent = (voltage - 3.0) / (4.2 - 3.0) * 100
        percent = max(0, min(100, percent))

        print(f"Battery: {voltage:.2f}V ({percent:.0f}%)")
        time.sleep(5)
except:
    print("Battery measurement not configured")
```

## Flash Storage

```python
import uos

# List files
print("Files:", uos.listdir())

# Write file
with open('data.txt', 'w') as f:
    f.write('Hello XIAO nRF52840')

# Read file
with open('data.txt', 'r') as f:
    data = f.read()
    print(f"Read: {data}")
```

## Key Differences from ESP32

| Feature | ESP32 | nRF52840 |
|---------|-------|----------|
| Wireless | WiFi + BLE | BLE only |
| USB | Device only | Device only |
| Bootloader | Serial | UF2 drag-and-drop |
| Flashing | esptool | Copy UF2 file |
| Deep Sleep | Full support | Limited support |
| Power | Higher | Better for BLE |

## Typical Current Consumption

| Mode | Current |
|------|---------|
| Active | 5mA |
| BLE advertising | 5mA |
| BLE connected | 3-5mA |
| System On sleep | 30µA |
| System Off | 2µA |

## Troubleshooting

### Can't see UF2 drive

1. Double-click RESET button quickly
2. Check for "FDRNRF52840" drive
3. Try different USB cable
4. Check LED indicates bootloader mode

### Thonny can't connect

1. Check device manager for COM port
2. Verify MicroPython installed
3. Try reinstalling firmware
4. Check baud rate (115200)

### BLE not working

1. Check BLE is active: `ble.active(True)`
2. Verify advertising parameters
3. Check for other BLE devices interference
4. Restart if needed

### Deep sleep not working

1. nRF52840 has limited deep sleep support
2. Use lightsleep as alternative
3. May need custom firmware for full deep sleep

### High power consumption

1. Ensure BLE advertising interval is long
2. Disable unused peripherals
3. Use system off when possible
4. Check for floating GPIO pins

## Best Practices

1. **Use UF2 bootloader** - easy firmware updates
2. **Optimize BLE advertising** - longer intervals save power
3. **Use light sleep** - better than deep sleep on nRF
4. **Disable NFC** if not needed
5. **Use flash storage** for data persistence
6. **Optimize BLE connection parameters**
7. **System Off** for battery devices

## Complete Example: BLE Sensor

```python
import bluetooth
import struct
import time
from machine import ADC, Pin

# BLE setup
ble = bluetooth.BLE()
ble.active(True)

# Sensor (ADC on A0)
adc = ADC(Pin(3))

# Define environmental service
_ENV_SENSING_UUID = bluetooth.UUID(0x181A)
_TEMP_UUID = bluetooth.UUID(0x2A6E)

# Register service
env_service = (_ENV_SENSING_UUID, (
    (_TEMP_UUID, bluetooth.FLAG_READ | bluetooth.FLAG_NOTIFY),
),)

handles = ble.gatts_register_services((env_service,))
(temp_handle,) = handles[0]

# Read temperature
def read_temp():
    value = adc.read_u16()
    voltage = value * 3.3 / 65535
    # Approximate temperature (adjust for your sensor)
    temp = int((voltage - 0.5) * 100)
    return temp

# Advertising
def advertise():
    name = b'XIAO-Sensor'
    adv_data = struct.pack('BB', 0x02, 0x01)  # Flags
    adv_data += struct.pack('BB', len(name) + 1, 0x09)  # Name
    adv_data += name

    ble.gap_advertise(100, adv_data)

# IRQ handler
def ble_irq(event, data):
    if event == 1:  # Connected
        print("Connected")
    elif event == 2:  # Disconnected
        print("Disconnected")
        advertise()

ble.irq(ble_irq)

# Start
advertise()

# Main loop
last_update = 0

while True:
    now = time.ticks_ms()

    # Update every 5 seconds
    if time.ticks_diff(now, last_update) > 5000:
        temp = read_temp()
        ble.gatts_write(temp_handle, struct.pack('<h', temp))
        ble.gatts_notify(0, temp_handle)
        print(f"Temp: {temp/100}°C")
        last_update = now

    time.sleep(0.1)
```

## Migration from Arduino

```python
# Arduino nRF52840 code needs changes for MicroPython:

# 1. No setup/loop structure - just top-level code
# 2. Pin numbers: Use Pin(gpio_number) not D6
# 3. Different BLE API - use bluetooth module
# 4. Different sleep functions
# 5. Interrupts: use Pin.irq() not attachInterrupt()

# Example Arduino:
# void setup() {
#     pinMode(6, OUTPUT);
# }
# void loop() {
#     digitalWrite(6, HIGH);
#     delay(1000);
# }

# MicroPython equivalent:
from machine import Pin
import time

led = Pin(6, Pin.OUT)

while True:
    led.value(1)
    time.sleep(1)
    led.value(0)
    time.sleep(1)
```
